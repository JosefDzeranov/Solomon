Program cell1;
const k=13;
var
 
 
 
 
 
{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!}
fin, fout: text;
 
Que : array [1..8192,1..2] of integer; { Очередь ходов }  {НЕ ЗНАЮ ЗАЧЕМ У ЧУВАКА БЫЛО 64, ПОХОДУ ПОТОМУ ЧТО 2^8.
  ПОЭТОМУ 8192 - 2^13, БОЛЬШЕ НЕ ВЛАЗИТ}
 
{Marked : array [1.. 8,1..8] of boolean; { Пометки на доске}
 
Marked : array [1..k,1..k] of boolean; { Пометки на доске}
 
{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!}
 
 
 
 
 
x,y,m,n, { Текущая позиция}
StepNumber, { Номер хода}
QueBegin, QueEnd, d : integer; { Начало и конец очереди}
 
procedure Put(x,y:integer); { Занести в очередь}
begin
Inc(QueEnd); { увеличить количество }
Que[QueEnd,1] := x; { координата по x }
Que[QueEnd,2] := y; { координата по y }
Marked[x,y] := true; { Помечаем использованную}
end;
 
procedure Get(var x,y:integer); { Взять из очереди }
begin
x := Que[QueBegin,1]; { координата по x }
y := Que[QueBegin,2]; { координата по y }
Inc(QueBegin); { изменить начало }
end;
 
procedure StartProcess;
var
c: char;
i,j,x,y : integer;
begin
 
 
 
 
{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!}
assign(fin,'remsquar.in');
reset(fin);
 
for i:= 1 to k do { Все клетки }
    for j:= 1 to k do Marked[i,j] := false; { непомечены }
readln(fin,m,n);
for i:=1 to m do
begin
    for j:=1 to n do
    begin
         read(fin,c);
         if c='.' then
            Marked[i,j] := true;
    end;
    readln(fin);
end;
close(fin);
{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!}
 
 
 
 
QueBegin := 1; { Начало очереди }
QueEnd :=0; { Конец очереди }
end;
 
function Found(var x,y:integer):boolean;
var i,j : integer;
begin
for i:=1 to m do
for j:=1 to n do
if not Marked[i,j]
then begin x:=i; y:=j; Found:=true; exit; end;
Found := false;
end;
 
procedure PutAll(x,y:integer); {Занести в очередь}
type {все текущие возможные ходы}
King = array [1..4,1..2] of integer; {Возможные ходы коня}
{!!!!!!! ПИПЕЦ, ПРИ ЧЕМ ТУТ КОНЬ... ТЕМ БОЛЕЕ ОН ТАК НЕ ХОДИТ, ТАК ХОДИТ ФИШКА ИЗ ИГРЫ "УГОЛКИ"}
const
Steps : King =(( 0,-1), ( 0, 1), (-1, 0), ( 1, 0)); {Массив констант}
Var i, CurrentX, CurrentY : integer;
begin
i:=0; {номер возможного хода}
while (i<4) do {Пока не нашли и есть ход}
begin {Делаем следующий ход }
inc(i);
CurrentX := x+steps[i,1] ; {X текущего хода }
CurrentY := y+steps[i,2] ; {Y текущего хода }
if (CurrentX>0) and (CurrentX<m+1) and { X на доске и }
(CurrentY>0) and (CurrentY<n+1) and { Y на доске и }
not Marked[CurrentX,CurrentY] {поле (X,Y) не помечено}
then Put(CurrentX,CurrentY); {помещаем в очередь}
end;
end;
 
 
begin
    StartProcess; { Начало работы }
    StepNumber:=0; { Номер куска = 0 }
    while (Found(x,y)) do { Пока есть непомеченная x,y }
    begin
    Put(x,y); { Помещаем ее в очередь и помечаем}
    Inc(StepNumber); { Увеличить номер куска на 1 }
    while QueBegin<=QueEnd do { Пока очередь непуста }
    begin
    Get(x,y); { Взять из очереди x,y }
    PutAll(x,y); { Занести в очередь все возможные ходы}
    end;
    end;
 
{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!}
    {writeln(StepNumber); { Вывод номера шага}
    assign(fout,'remsquar.out');
    rewrite(fout);
    write(fout,StepNumber);
    close(fout);
{!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!}
 
 
end.